# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

from optparse import Option
from typing import List, Optional, Union, cast

import torch

import abc
import theseus
import theseus.constants

from .lie_group import LieGroup


class ProductLieGroup(LieGroup):
    def __init__(self, groups: List[LieGroup],
                 name: Optional[str] = None,
                 dtype: Optional[torch.dtype] = None,
                 strict: bool = False,
                 ):
        self.groups: List[LieGroup] = List([group.copy() for group in groups])
        super().__init__(tensor=torch.empty([1, 0]), name=name, dtype=dtype, strict=strict)
        self.tensor = torch.cat([group.tensor.view(group.shape[0], -1) for group in self.groups])
        self._dof = sum([group.dof() for group in self.groups])
        self._numel = sum([group.numel() for group in self.groups])

    @staticmethod
    def rand(
        *size: int,
        generator: Optional[torch.Generator] = None,
        dtype: Optional[torch.dtype] = None,
        device: Optional[torch.device] = None,
        requires_grad: bool = False,
        group_clses: List[abc.ABCMeta]
    ) -> "LieGroup":
        if not any([issubclass(group_cls, LieGroup) for group_cls in group_clses]):
            raise ValueError("All the group classes must be the subclasses of these.LieGroup.")

        return ProductLieGroup(groups=[group_cls.rand(size, generator, dtype, device,
                                                      requires_grad) for group_cls in group_clses])

    @staticmethod
    def randn(
        *size: int,
        generator: Optional[torch.Generator] = None,
        dtype: Optional[torch.dtype] = None,
        device: Optional[torch.device] = None,
        requires_grad: bool = False,
        group_clses: List[abc.ABCMeta]
    ) -> "LieGroup":
        if not any([issubclass(group_cls, LieGroup) for group_cls in group_clses]):
            raise ValueError("All the group classes must be the subclasses of these.LieGroup.")

        return ProductLieGroup(groups=[group_cls.randn(size, generator, dtype, device,
                                                       requires_grad) for group_cls in group_clses])

    @staticmethod
    def _init_tensor() -> torch.Tensor:
        return torch.empty([1, 0])

    def dof(self) -> int:
        return self._dof 

    def numel(self) -> int:
        return self._numel
